---
description: Coding standards and best practices for this project
globs: ["src/**/*.{ts,tsx,scss}", "cypress/**/*.{ts,tsx}", "**/*.test.{ts,tsx}"]
alwaysApply: false
---

# Coding Standards

These are the coding standards for the KubeVirt Plugin project. They apply to source code, tests, and styles (see globs). All code contributions should follow these guidelines.

---

## 1. File Conventions

### File Extensions
- **Components**: `.tsx` for all React components
- **Logic/Utilities**: `.ts` for non-component files (hooks, utils, types, constants)
- **Styles**: `.scss` for component styles
- **Tests**: `.test.ts` or `.test.tsx` for unit tests

### File Naming
- **Component files**: PascalCase matching component name (`VMDetailsPage.tsx`)
- **Non-component files**: camelCase (`vmUtils.ts`, `useVMData.ts`)
- **SCSS files**: kebab-case matching component (`vm-details-page.scss`)
- **Type files**: camelCase (`types.ts`, `vmTypes.ts`)
- **Constant files**: camelCase (`constants.ts`)

### Folder Naming
- Always lowercase kebab-case
- Examples: `/components/vm-details/`, `/hooks/use-vm-data/`

### File Size Limits
- Maximum **150 lines** per file
- If exceeding, split into smaller modules
- One component per file, no nested component definitions

---

## 2. Component Structure

### Folder Organization
```
/components/my-component/
├── MyComponent.tsx           # Main component
├── my-component.scss         # Styles
├── index.ts                  # Optional barrel export
├── components/               # Sub-components
│   ├── Header.tsx
│   └── Footer.tsx
├── hooks/                    # Component-specific hooks
│   └── useMyComponentData.ts
├── utils/                    # Component-specific utilities
│   ├── helpers.ts
│   └── constants.ts
└── types/                    # Component-specific types
    └── types.ts
```

### Component Rules
- One component per file
- No nested component definitions inside other components
- Filename must match component name
- Use functional components exclusively
- Class components only for error boundaries (`componentDidCatch`)

---

## 3. React Patterns

### Component Function Order
1. Imports (external, then internal, then styles)
2. Type definitions (props, local types)
3. Constants (small ones; large go to separate file)
4. Component function
5. Default export

### Inside Component Order
1. Translation hook (`useKubevirtTranslation`)
2. Router hooks (`useParams`, `useNavigate`)
3. Data fetching hooks (`useK8sWatchResource`)
4. Local state (`useState`)
5. Derived values (`useMemo`)
6. Callbacks (`useCallback`)
7. Effects (`useEffect`)
8. Early returns (loading, error, empty states)
9. Main JSX return

### Hooks Best Practices
- Always specify dependencies in `useEffect`
- Empty array `[]` for mount-only effects
- Hooks contain logic only, never return JSX
- Extract complex logic to custom hooks
- Follow the `use` prefix convention

### Memoization
- Use `React.memo` for components with stable props but re-rendering parents
- Use `useMemo` for expensive calculations
- Use `useCallback` for callbacks passed to memoized children
- Don't over-memoize simple operations

### Exports
- Default export for components
- Named exports for utilities, hooks, types

---

## 4. TypeScript Standards

### Type vs Interface
- Prefer `type` over `interface` for object shapes
- Use `interface` only when extending is needed

### Type Safety
- **Never use `any`** - use `unknown` and narrow with type guards
- Always define explicit return types on functions
- Use optional chaining (`?.`) for nullable access
- Provide fallback values with nullish coalescing (`??`)

### Naming Conventions
- Types: PascalCase (`VMConfig`, `UserAction`)
- Constants: UPPER_SNAKE_CASE (`DEFAULT_NAMESPACE`, `MAX_RETRIES`)
- Functions/variables: camelCase (`getVMStatus`, `vmList`)
- Components: PascalCase (`VMDetailsPage`)

### Type Organization
- Component-specific types: in component's `types/` folder
- Shared types: in `src/utils/types/`
- Use existing types from `@kubevirt-ui/kubevirt-api`

---

## 5. Styling Guidelines

### SCSS Usage
- One SCSS file per component
- Filename matches component: `VMDetails.tsx` → `vm-details.scss`
- Place in same directory as component
- Import at top of component file

### BEM Methodology
- **Block**: Component name (`.vm-details`)
- **Element**: Child parts (`&__header`, `&__content`)
- **Modifier**: Variations (`&--loading`, `&--compact`)

### PatternFly Integration
- Use PatternFly variables for spacing, colors, typography
- Don't target PatternFly class names directly in selectors
- Add project-specific class names as anchors
- Classes change between PF versions

### Rules
- No `!important` unless absolutely necessary
- Use relative units (rem, %, em) over absolute (px)
- Use CSS variables for theming support

---

## 6. Error Handling

### Principles
- Never swallow errors silently
- Always provide meaningful error messages
- Log errors for debugging
- Show user-friendly messages in UI
- Provide recovery paths when possible

### Async Operations
- Wrap in try/catch
- Handle loading, success, and error states
- Clean up on component unmount

---

## 7. Code Quality

### Comments
- Avoid comments when possible; write self-documenting code
- Use comments for non-obvious decisions
- Include links to issues for workarounds
- Document public APIs

### Naming
- Use descriptive names over abbreviations
- Function names should describe action: `fetchVMData`, `handleSubmit`
- Boolean variables: `isLoading`, `hasError`, `canEdit`

### Magic Numbers
- Define as named constants
- Place in `constants.ts` file
- Include units in name: `POLL_INTERVAL_MS`, `MAX_RETRIES`

### Code Duplication
- Extract repeated code to utilities
- Create custom hooks for repeated logic patterns
- Use generics for type-safe reusable functions

---

## 8. Testing

### Requirements
- New features must have tests
- Bug fixes should include regression tests
- Aim for behavior testing over implementation testing

### Tools
- Jest for unit tests
- React Testing Library for component tests
- Cypress for E2E tests

---

## 9. Version Control

### Commits
- Meaningful commit messages
- Small, focused commits
- Don't commit broken code
- Can be squashed on merge

### Pull Requests
- Small, dedicated PRs over large ones
- Include description, JIRA link, screenshots/video
- Self-review before requesting review
- No merge without peer review

---

## 10. Linting & Formatting

### Tools
- ESLint with React and TypeScript plugins
- Prettier for formatting
- Husky for pre-commit hooks
- lint-staged for staged file checking

### Commands
```bash
npm run lint          # Check for issues
npm run lint:fix      # Auto-fix issues
```

### Rules
- Don't skip pre-commit hooks
- Fix linting errors before committing
- Configure editor for format-on-save
